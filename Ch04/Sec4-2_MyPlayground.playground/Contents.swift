import SwiftUI

/**
 Swift シンタックスの基礎知識
 - 配列
 */

/**
 -----------------------------------------------------------------
 配列を作る。
 var  配列名 : [要素の型] = [ 要素1, 要素2, 要素3, ...]
 ※ let で定義した場合は、定数宣言なので後から追加・削除などの変更はできない。
 -----------------------------------------------------------------
 */
配列を作る: do {
    // 配列を宣言
    let week   : [String]
    var nums   : [Int]
    var colors : [Color]

    week = ["日", "月", "火", "水", "木", "金", "土"]  // letで宣言しているので、初期化以降は変更不可
    nums = [4, 8, 15, 16, 23, 42]
    colors = [.red, .yellow, .green]

    print(week)
    print(nums)
    print(colors)
}


/**
 -----------------------------------------------------------------
 引数で渡した変数の型を調べる。
 type(of : 変数名)
 ※ 戻り値の型が何なのかは一旦スルー
 -----------------------------------------------------------------
 */
配列の型を型推論で決める: do {
    let week = ["日", "月", "火", "水", "木", "金", "土"]
    var nums = [4, 8, 15, 16, 23, 42]

    // 変数の型を調べる
    print(type(of: week))   // Array<String>
    print(type(of: nums))   // Array<Int>
}

/**
 -----------------------------------------------------------------
 先頭から0, 1, 2と数える。
 配列[インデックス番号]
 -----------------------------------------------------------------
 */
配列の値を参照する: do {
    let ABC_ARRAY = ["a", "b", "c", "d"]
    let LETTER_0  = ABC_ARRAY[0]
    let LETTER_2  = ABC_ARRAY[2]

    print(LETTER_0)     // a
    print(LETTER_2)     // b
}

/**
 -----------------------------------------------------------------
 添字で指定した要素を更新する。
 -----------------------------------------------------------------
 */
配列の要素を更新する: do {
    var fruits = ["blueberry", "orange", "peach"]
    fruits[1]  = "apple"
    print(fruits)       // ["blueberry", "apple", "peach"]
}

/**
 -----------------------------------------------------------------
 レンジ演算子...  インデックスの範囲を指定すれば、その範囲の要素を入れ替えることがで
 きる。
 - 参照しているレンジの数と置き換える要素の数が同じでなくてもよい。
 -----------------------------------------------------------------
 */
レンジで指定した要素を更新する: do {
    var colors = ["green", "red", "blue", "pink"]
    colors[1...2] = ["赤", "青", "黄"]     // インデックス番号1~2の範囲を入れ替える
    print(colors)                         // ["green", "赤", "青", "黄", "pink"]
}

/**
 -----------------------------------------------------------------
 配列に要素を追加する。
 配列.appned(要素)
 - 要素を追加する配列は初期化済みでなければならない。
 - 空の配列では型を推論できないので、明示的に型を指定する必要がある。
 -----------------------------------------------------------------
 */
空の配列に要素を追加していく: do {
    var words : [String] = []       // String型の空の配列
    words.append("花")
    words.append("鳥")
    words.append("風")
    words.append("月")
    print(words)                    // ["花", "鳥", "風", "月"]
}

/**
 -----------------------------------------------------------------
 空の配列は[]を代入すれば作ることができるが、型を指定した初期化済の空の配列を
 以下のように作ることも可能。
 - [要素の型]()
 - Array<要素の型>()

 複数の要素を一度に追加できる。
 - appned(contentsOf:)
 -----------------------------------------------------------------
 */
空の配列を作る: do {
    var members = [String]()    // String型の空の配列

    members.append("五郎")
    members.append("四郎")
    members.append(contentsOf: ["一郎", "二郎", "三郎"])

    print(members)              // ["五郎", "四郎", "一郎", "二郎", "三郎"]
}

/**
 -----------------------------------------------------------------
 同じ型同士の配列であれば、配列A + 配列Bのように+演算子で足し算することで連結が可能。
 -----------------------------------------------------------------
 */
配列を連結する: do {
    let BASIC_COURSE  = ["ラン", "スイム"]
    let OPTION_COURSE = ["バイク", "カヌー"]
    let FULL_COURSE   = BASIC_COURSE + OPTION_COURSE    // 2つの配列の要素を連結する
    print(FULL_COURSE)                                  // ["ラン", "スイム", "バイク", "カヌー"]
}

/**
 -----------------------------------------------------------------
 +-演算子を使って配列を連結する。
 - 配列の連結には代入演算子+-も利用できる。

 ソートは、コレクション変数名.sort()で行う。
 - 昇順
    - コレクション.sort()
 - 降順
    - コレクション.sort(by: >)
 -----------------------------------------------------------------
 */
空の配列に別の配列を連結して_最後にソートする: do {
    // 連結用のDouble型の配列 ※空で初期化済み
    var data = Array<Double>()
    // 数値が格納された配列
    let DATA_1 = [3.6, 5.7, 2.2]
    let DATA_2 = [4.0, 3.1, 5.3]
    // 配列を連結する
    data += DATA_1
    data += DATA_2
    // 小さい順にソート
    data.sort()
    print(data)             // [2.2, 3.1, 3.6, 4.0, 5.3, 5.7]

    // 大きい順にソート
    data.sort(by: >)
    print(data)             // [5.7, 5.3, 4.0, 3.6, 3.1, 2.2]
}

/**
 -----------------------------------------------------------------
 配列をスライスする。
 - 配列の一部を取り出して新しい配列を作ることを「スライス」と呼ぶ。
 - 配列をスライスするには、レンジ演算子を使って取り出したい範囲のインデックスを指定
 する。
 -----------------------------------------------------------------
 */
配列をスライスして一部分を取り出す: do {
    let COLOR_LIST = ["blue", "yellow", "red", "green", "pink"]
    let MY_COLOR   = COLOR_LIST[1...3]      // 配列のインデックス番号1~3の要素を取り出した配列を代入する
    print(MY_COLOR)                         // ["yellow", "red", "green"]
}

/**
 -----------------------------------------------------------------
 NAMES.count/2の結果は3となる。
 - NAMESには7つの要素が入っており、Int型かつ2で割り切れないため。
 -----------------------------------------------------------------
 */
配列の前半と後半を取り出した配列を作る: do {
    let NAMES = ["鈴木", "松原", "曽根", "安藤", "山田", "山本", "松田"]
    let HALF  = NAMES.count/2           // 3
    let GROUP_1 = NAMES[..<HALF]        // 0 ~ 2 まで
    print(GROUP_1)                      // ["鈴木", "松原", "曽根"]

    let GROUP_2 = NAMES[HALF...]        // 3 ~ 上限まで
    print(GROUP_2)                      // ["安藤", "山田", "山本", "松田"]
}
