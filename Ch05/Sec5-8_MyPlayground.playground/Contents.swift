import UIKit

/**
 -----------------------------------------------------------------
 Swift シンタックスの基礎知識 - オプショナルバインディング

 ■ nilかもしれないオプショナルバリュー
 Swiftでは`通常の変数にはnilを代入できなくしてある。`ただし、変数を宣言する際に
 `num: Int?`のように`型の後ろに ? を付ける`と普通のInt型ではなく`Optional型`
 になり、numはInt型の変数だけでなく`nilも代入できる`変数になる。Optional型の値
 すなわち`「nilかもしれない値」をオプショナルバリュー`と呼ぶ。
 -----------------------------------------------------------------
 */
変数にnilを代入するとエラーになる: do {
    var num: Int
    num = 5         // 代入可
//    num = nil     // 代入不可 ※エラーになるためコメントアウト
    print(num)      // 5
}

nilを代入できる変数をつくる: do {
    var num: Int?
    num = nil       // 代入可
    num = 5
    print(num)      // Optional(5)
}

/**
 -----------------------------------------------------------------
 ■ オプショナルバリューはそのままでは使えない
 -----------------------------------------------------------------
 */
オプショナルバリューはそのまま使えない: do {
    let nums: [Int] = [1, 2, 3]
    let lastNum = nums.last
//    print(lastNum * 2)      // Optional型でラップされているので、エラー
}

/**
 -----------------------------------------------------------------
 ■ オプショナルバリューで強制アンラップして使う
 Optionalから取り出すことを`アンラップ`と言う。アンラップの方法はいくつかあるが、
 ひとつとしてオプショナルバリューに`!`をつける方法。強制アンラップする対象がnilだ
 った場合は、当然エラーになる。そのため、
 `強制アンラップは、値がnilではないことが確定しているときのみ使用する`こと。
 -----------------------------------------------------------------
 */
オプショナルバリューを強制アンラップする: do {
    var num: Int?
    num = 5
    print(num)      // Optional(5)
    print(num!)     // 5 ※強制アンラップ
}

オプショナルバリューを強制アンラップして計算する: do {
    let nums: [Int] = [1, 2, 3]
    let lastNum = nums.last!        // 強制アンラップ
    print(lastNum * 2)              // 6
}

/**
 -----------------------------------------------------------------
 ■ オプショナルバリューがnilだった場合は代替値を使う ??演算子
 オプショナルバリューがnilだった場合は代わりとなる値を指定しておく方法がある。それ
 が、`??演算子`。
 -----------------------------------------------------------------
 */
nilだった場合は0を使う: do {
    let nums: [Int] = []
    let lastNum = nums.last ?? 0        // nums.lastがnilだった場合は0をセット
    print(lastNum * 2)                  // 0
}

/**
 -----------------------------------------------------------------
 ■ guard let-elseを使ったオプショナルバインディング
 アンラップの方法として`オプショナルバインディング`がある。オプショナルバリューが
 nilでなければアンラップして変数に代入する構文。`guard let-else文`は関数を実
 行する前にオプショナルバリューをチェックするために用いられる事が多い。場合によっ
 ては、letではなくvarで宣言しても良い。
 ```Swift guard let-elseの書式
 guard let 変数 = オプショナルバリュー else {
    オプショナルバリューがnilの場合のステートメント
    return 返却値 ※処理中断
 }
 アンラップして変数に代入した値を使うステートメント
 ```
 オプショナルバリューが`nilではないときには、Optional(値)のようにラップされて`
 `いる値をアンラップして変数に代入`してguard文を抜け、そのままguard文より以降の
 処理を続行する。値が`nilだった場合は elseブロックを実行`し、returnで値を返却
 して関数を中断する。値を返却しない関数であれば、returnのみ定義すればよい。
 -----------------------------------------------------------------
 */
個数をチェックする: do {
    let quantity: String = String(Int.random(in: 0..<20))     // 0 ~ 20の乱数

    /// 個数チェック
    /// - Parameters:
    ///   - min: 最小値
    ///   - max: 最大値
    /// - Returns: 範囲内かどうか判定結果を返却
    func quantityCheck(min: Int, max: Int) -> Bool {
        guard let num = Int(quantity) else {
            return false
        }
        // 個数が範囲内であればtrue
        return (min...max).contains(num)
    }
    // 範囲を1 ~ 10に設定して出力する
    print("個数は\(quantity)です。判定結果 : \(quantityCheck(min: 1, max: 10))")
}

/**
 -----------------------------------------------------------------
 ■ if let-elseを使ったオプショナルバインディング
 `if let-else文`でもオプショナルバリューが
 `nilでないときに値をアンラップして変数に代入`できる。オプショナルバリューが
 `nilだった場合はelseブロックを実行`する。
 `guard let-else文は値がnilだった場合に、処理をキャンセルしていることをハッキ
 `リと示すのが目的`だが、`if let-else文は場合に応じて処理を分岐して続けたい`
 場合に使われる。
 ```Swift if let-elseの書式
 if let 変数 = オプショナルバリュー {
    アンラップして変数に代入した値を使うステートメント
 } else {
    オプショナルバリューがnilの場合のステートメント
 }
 -----------------------------------------------------------------
 */
料金を計算する: do {
    var quantity: Int = .random(in: 0 ..< 20)

    // Initializer for conditional binding must have Optional type, not 'Double'というエラー発生
    // quantityが絶対nilにならないから？、または別の原因なのか不明
    func priceCalc() -> Int {
        if let num = Double(quantity) {
            let result = Int(num * 1.1)
            return result
        } else {
            return -1
        }
    }
    print(priceCalc())
}
